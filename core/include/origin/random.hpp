// Copyright (c) 2008-2010 Kent State University
// Copyright (c) 2011-2012 Texas A&M University
//
// This file is distributed under the MIT License. See the accompanying file
// LICENSE.txt or http://www.opensource.org/licenses/mit-license.php for terms
// and conditions.

#ifndef ORIGIN_RANDOM_HPP
#define ORIGIN_RANDOM_HPP

#include <random>
#include <string>

#include <origin/container_fwd.hpp>
#include <origin/algorithm.hpp>
#include <origin/concepts.hpp>

namespace origin
{
  // TODO: Build better tools for creating custom distributions. I think that
  // these will essentially be in the form of constructor functions that
  // support distribution composition.

  
  
  // Random bit generator (concepts)
  // A random bit generator (called uniform random number generator in the
  // standard), generates uniformly distributed sequences of random bits
  // usually as 32 or 64 bit unsigned values.
  //
  // FIXME: Add min/max requirements.
  //
  // FIXME: Rename to Pseudorandom number generator?
  template <typename Gen>
    constexpr bool Random_bit_generator()
    {
      return Has_result_type<Gen>() // Gen::result_type
          && Function<Gen>();       // gen() -> result_type
    }
  

  
  // Random number engine (concept)
  // A random number engine is a random bit generator that provides support
  // for equality comparison, I/O, and seeding.
  //
  // FIXME: Add seeding requirements.
  template <typename Eng>
    constexpr bool Random_number_engine()
    {
      return Random_bit_generator<Eng>()
          && Equality_comparable<Eng>() 
          && Streamable<Eng>();
    }
  

  // FIXME: Implement traits to detect parameter types, etc.
  
  
  // Random value generator (concept)
  // A random value generator transforms the data returned by a random bit
  // generator into a randomly constructed value of a specified type. An
  // example of a random value generator is a password generator. Random number
  // distributions are special kinds of random value generators.
  //
  // FIXME: Random value generators are also parameterized, often by other
  // ranodm value generators or random number distributions. I should have the
  // same kinds of requirements here that the random number distributions do.
  //
  // FIXME: Add re-add Streamable requirements
  template <typename Gen>
    constexpr bool Random_value_generator()
    {
      return Equality_comparable<Gen>()
          && Function<Gen, std::minstd_rand&>();
    }

  
  
  // Random number generator (concept)
  // A random number generator distributes the values returned by a random
  // number engine according to a probability function (distribution).
  //
  // FIXME: Ranodm number generators have min/max in addition to the properties
  // of a random value generator. They should also have associated functions
  // like pdf, cdf, mean, variance, etc (the Boost.Math stuff).
  template <typename Dist>
    constexpr bool Random_number_generator()
    {
      return Random_value_generator<Dist>();
    }

  
  
  // Algorithms
  // FIXME: Move these to algorithms.

  
  
  // Random generate (iterator)
  // Fill the objects in [first, last) with values randomly generated by gen
  // and distributed by dist.
  //
  // FIXME: Write requirements
  template <typename I, typename Eng, typename Gen>
    void generate_random(I first, I last, Eng&& eng, Gen&& gen)
    {
      while(first != last) {
        *first = gen(eng);
        ++first;
      }
    }
    
    
    
  // Random generate (range)
  // Fill the objects in range with values randomly generated by gen and
  // distributed by dist.
  //
  // FIXME: Write requirements.
  template <typename R, typename Eng, typename Gen>
    void generate_random(R&& range, Eng&& eng, Gen&& gen)
    {
      generate_random(o_begin(range), o_end(range),
                      std::forward<Eng>(eng),
                      std::forward<Gen>(gen));
    }

    

  // TODO: Implement a zipf distribution to help generate realistic string
  // lengths.
  template <typename T>
    class zipf_distribution
    {
    };
    


  // Default distribution (facility)
  // The default distribution facility provides access to default random
  // distributions for a type. It is used like this:
  //
  //    auto dist = default_distribution<T>()
  //
  // where T is a type that has a default distribution. Note that the default
  // distribution type (decltype(dist)), can also be accessed using:
  //
  //    Default_distribution_type<T>
  //
  // FIXME: Rename to default_generator! Only random numbers are distributed
  // in the sense of a probability function. Other value-like elements are
  // distributed in multiple properties.

  
  
  // Default distribution (traits)
  // The default distribution traits can be used to specialize the default
  // distribution for a type or class of types.
  template <typename T>
    struct default_distribution_traits;

    
  
  // Default distribution (algorithm)
  // Returns the default random value distribution for T.
  template<typename T>
    auto default_distribution() 
      -> decltype(default_distribution_traits<T>::get())
    {
      return default_distribution_traits<T>::get();
    }


  
  // Default distribution type (alais)
  // An alias to the type of the default distribution for the type T.
  template <typename T>
    using Default_distribution_type 
      = decltype(default_distribution_traits<T>::get());

      

  // Constant value generator (random value generator)      
  // A constant value generator continuously generates the same value. Note
  // that the value type T must be equality comparable.
  template <typename T>
    struct constant_value_generator
    {
      static_assert(Equality_comparable<T>(), "");

      using result_type = T;

      constant_value_generator(const T& x) : value(x) { }

      template <typename Eng>
        const result_type& operator()(Eng& eng) const
        {
          return value;
        }

      // Equality comparable
        bool operator==(const constant_value_generator& x) const
        {
          return value == x.value;
        }

        bool operator!=(const constant_value_generator& x) const
        {
          return value != x.value;
        }

      T value;
    };



  // Random sequence generator (random value generator) 
  // The random sequence distribution creates random sequences of values with 
  // randomly generated size, which is determined by the Len distribution, 
  // whose values are distributed by the Gen distribution.
  //
  // FIXME: The default size distribution should be zipf or zeta.
  template <typename Seq, 
            typename Size = std::uniform_int_distribution<Size_type<Seq>>,
            typename Gen = Default_distribution_type<Value_type<Seq>>>
    class random_sequence_generator
    {
    public:
      random_sequence_generator(const Size& s = Size{0, 32},
                                const Gen& d = Gen{})
        : size{s}, gen{d}
      { }
      
      template <typename Eng>
        Seq operator()(Eng& eng)
        {
          Seq s(size(gen), Value_type<Seq>{});
          generate_random(s, eng, gen);
          return std::move(s);
        }
        
      // Equality comparable
      bool operator==(const random_sequence_generator& x) const
      {
        return size == x.size() && gen == x.gen;
      }
      
      bool operator!=(const random_sequence_generator& x) const
      {
        return !(*this == x);
      }
      
      Size size;
      Gen gen;
    };



  // Random string distribution (random distribution) 
  // The random string distribution creates random strings of with a randomly 
  // generated length, which is determined by the Len distribution, whose
  // characters are distributed by the Alpha distribution.
  //
  // By default, string lengths are uniformly distributed between 0 and 32
  // characters in length, and the characters are uniformly chosen from ASCII 
  // printable characters (32-127).
  template <typename Str, 
            typename Len = std::uniform_int_distribution<Size_type<Str>>,
            typename Alpha = std::uniform_int_distribution<Value_type<Str>>>
    class random_string_generator
      : public random_sequence_generator<Str, Len, Alpha>
    {
      using base_type = random_sequence_generator<Str, Len, Alpha>;
    public:
      random_string_generator(const Len& l = Len{0, 32},
                              const Alpha& a = Alpha{33, 126})
        : base_type(l, a)
      { }
    };
    


  // Random iterator generator (random value generator)
  // The random iterator generator returns iterators at random positions in
  // the given container. Positions are uniformly generated.
  //
  // TODO: Should we parameterize over the distribution of positions? That
  // would let us test operations close to the front or back.
  template <typename Cont>
    class random_iterator_generator
    {
      using Dist = std::uniform_int_distribution<Size_type<Cont>>;
    public:
      using result_type = Iterator_type<Cont>;

      random_iterator_generator(Cont& c) 
        : cont(c), dist(0, c.size() - 1)
        { }

      template <typename Eng>
        result_type operator()(Eng& eng)
        {
          return o_next(cont.begin(), dist(eng));
        }

      // Equality comparable
      // Two random iterator generators are equal if they generate iterators
      // into the same container with their positions having the same
      // distribution (currently, that's uniform).
      bool operator==(const random_iterator_generator& x) const
      {
        return &cont == &x.cont;
      }

      bool operator!=(const random_iterator_generator& x) const
      {
        return &cont != &x.cont;
      }

    private:
      Cont& cont;
      Dist dist;
    };

    

  // Default distribution (specializations)
      
  // Specialization for bool.
  template <>
    struct default_distribution_traits<bool>
    {
      static std::bernoulli_distribution get() { return {}; }
    };
    
  // A helper class for integral types.
  template <typename T>
    struct integral_distribution_traits
    {
      static std::uniform_int_distribution<T> get() 
      { 
        return std::uniform_int_distribution<T>{
          std::numeric_limits<T>::min(),
          std::numeric_limits<T>::max()
        };
      }
    };
    
  // A helper traits class for floating point types.
  template <typename T>
    struct floating_point_distribution_traits
    {
      static std::uniform_real_distribution<T> get()
      { 
        return std::uniform_real_distribution<T>{
          std::numeric_limits<T>::min(),
          std::numeric_limits<T>::max()
        };
      }
    };

  template <> struct default_distribution_traits<char> : integral_distribution_traits<char> { };
  template <> struct default_distribution_traits<signed char> : integral_distribution_traits<signed char> { };
  template <> struct default_distribution_traits<unsigned char> : integral_distribution_traits<unsigned char> { };

  template <> struct default_distribution_traits<short> : integral_distribution_traits<short> { };
  template <> struct default_distribution_traits<int> : integral_distribution_traits<int> { };
  template <> struct default_distribution_traits<long> : integral_distribution_traits<long> { };
  template <> struct default_distribution_traits<long long> : integral_distribution_traits<long long> { };
  
  template <> struct default_distribution_traits<unsigned short> : integral_distribution_traits<unsigned short> { };
  template <> struct default_distribution_traits<unsigned int> : integral_distribution_traits<unsigned int> { };
  template <> struct default_distribution_traits<unsigned long> : integral_distribution_traits<unsigned long> { };
  template <> struct default_distribution_traits<unsigned long long> : integral_distribution_traits<unsigned long long> { };
  
  template <> struct default_distribution_traits<float> : floating_point_distribution_traits<float> { };
  template <> struct default_distribution_traits<double> : floating_point_distribution_traits<double> { };
  template <> struct default_distribution_traits<long double> : floating_point_distribution_traits<long double> { };
  
  // Specialization for strings.
  template <typename C, typename T, typename A>
    struct default_distribution_traits<std::basic_string<C, T, A>>
    {
      static random_string_generator<std::basic_string<C, T, A>> get() 
      { 
        return random_string_generator<std::basic_string<C, T, A>>{}; 
      }
    };
    
  // A helper trait for sequences
  template <typename Seq>
    struct sequence_distribution_traits
    {
      static random_sequence_generator<Seq> get()
      {
        return random_sequence_generator<Seq>{};
      }
    };
    
  // Specialization for sequence types
  template <typename T, typename A>
    struct default_distribution_traits<std::vector<T, A>> 
      : sequence_distribution_traits<std::vector<T, A>>
    { };

  template <typename T, typename A>
    struct default_distribution_traits<std::forward_list<T, A>> 
      : sequence_distribution_traits<std::vector<T, A>>
    { };

  template <typename T, typename A>
    struct default_distribution_traits<std::list<T, A>> 
      : sequence_distribution_traits<std::vector<T, A>>
    { };

  template <typename T, typename A>
    struct default_distribution_traits<std::deque<T, A>> 
      : sequence_distribution_traits<std::vector<T, A>>
    { };



  // Return a random value from the default random value distribution 
  // associated with the type T.
  template <typename T, typename Gen>
    T random_value(Gen&& gen)
    {
      auto dist = default_distribution<T>();
      return dist(gen);
    }

  // Returns...
  template <typename Dist, typename Gen>
    auto random_value(Dist dist, Gen& gen) -> decltype(dist(gen))
    {
      return dist(gen);
    }

} // namespace origin

#endif
