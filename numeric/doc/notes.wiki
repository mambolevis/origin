
== Matrix Order Initialization ==
Initialization semantics for matrices is somewhat unclear for two reasons.
First, rectangular and square matrices have "competing" constructors.
Consdider::

  matrix M{m, n}

Does this initialize a rectangular m x n matrix or does it initialze a square
m x m matrix with an initial value of n? A third option would be to initialize
an m x 1 row matrix with an initial value of n. These questions are most
pronounced when the matrix's value type and size type are the same.

The difference dependes entirely on the backing store. Choosing rectangular
data will result in the first initialization (or possibly the third). Choosing
square data will result in the second initialization.

I am not in favor of implicitly constructing m x 1 row matrices. So far, I have
only seen this supported by Eigen.

The different initialization semantics are not readily enabled or disabled
because the difference depends on the enclosing class, not the constructor
parameters. It is probably possible to write the enabler in such a way that
it is dependent on an unused template parameter. For example:

  template<typename Size>
  matrix(Size, enable_if<is_square<this_type, Size>::value>::type* = 0);

This is not especially elegant, but it might work.

A better solution would be to implement different initialization semantics in
different base class depending on the backing store and inherit the
constructors into the matrix class. For example::

  template<typename Store> class rect_matrix;
  template<typename Store> class sq_matrix;

  template<typename T, typename Store>
  class matrix
    : conditional<
        is_square<Store>::value, rect_matrix<Store>, sq_matrix<Store>
      >::type
  {
    using base_type::base_type;
  };

This depends on inherited constructors, however. A workaround involving
a variadic constructor and forwarding was given on the C++ reflector.

== Matrix Value Initialization ==
The more complex problem with initialization is the interpretation of the
value type in the constructor. Do we interpret the value type as a fill
initializer, setting all matrix elements to the given value? Do we treat it
as a scalar assignment and make the result n * I where I is the identity
matrix.

I suspect that the latter approach is by far, the most appropriate for the
domaion. For example, writing::

  matrix m{n, n, 1}

Should produce an identity matrix, not a matrix with all ones.

== Matrix Data Initialization ==
The currentl implementation performs "double initialization" along the diagonal.
The underlying store is first initialized with all default values, and then
the diagonal is filled with the initial value.

This incurs a (small?) linear overhead. It would be better if we could
explicitly request a partially initialized data store and then fill it from
the matrix.

These requirements are somewhat problemat because it is not clear that they
can be satisfied in a general way. Maybe it would be better to simply define
a number of matrix classes that are tightly coupled to their underlying
data store (within reason?). Note that this would probably be the most
graceful solution to the square/rectangular matrix problem described above.



